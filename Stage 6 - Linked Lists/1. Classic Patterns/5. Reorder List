https://leetcode.com/problems/reorder-list/description/

https://www.youtube.com/watch?v=S5bfdUTrKLM

Input : Node
Keywords : nth node from end, middle of LL, cycle, one-pass linked list => fast and slow pointers
Constraints : The number of nodes in the list is in the range [1, 5 * 104].
              1 <= Node.val <= 1000

//Brute Force - iterative - 2 pointers
//TC = O(n)
//SC = O(n) - arrayList
class Solution {
    public void reorderList(ListNode head) {
        if(head == null){
            return;
        }

        //Put all nodes in an array list
        List<ListNode> nodeList = new ArrayList<ListNode>();
        ListNode temp = head;
        while(temp != null){
            nodeList.add(temp);
            temp = temp.next;
        }

        //Traverse from left and right of the array list
        int left = 0;
        int right = nodeList.size() - 1;

        while(left < right){
            // Set the 'next' of the node at 'left' to the node at 'right'
            nodeList.get(left).next = nodeList.get(right); 
            left++;
            if(left >= right){ // left may exceed right when we increment it
                break;
            }
            // Set the 'next' of the node at 'right' to the node at 'left'
            nodeList.get(right).next = nodeList.get(left);
            right--;
        }

        //nodeList.get(left) will be the last node after traversal as left moves forward
        //In example [1,2,3,4] , left moves to 0 -> 1 -> 2 -> 3
        //the last node should point to null
        nodeList.get(left).next = null;
    }
}

//Optimal - Fast and Slow pointers

- Find the middle of the list using the fast and slow pointer technique (Tortoise and Hare algorithm).
  - Fast moves 2 steps and slow moves 1 step.
  - When fast reaches the end of the list (fast == null or fast.next == null), 
  - slow will be at the middle of the list.
  - For an odd-length list, slow will be at the exact middle node.
  - For an even-length list, slow will be at the second of the two middle nodes.
- Split the list into two halves.
- Reverse the second half of the list.
- Merge the two halves one node at a time.

//TC = O(n)
//SC = O(1)

class Solution {
    public void reorderList(ListNode head) {
        //base : empty LL or only 1 node
        if(head == null || head.next == null){
            return;
        }

        // Find the middle of the list using the fast and slow pointer technique.
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }


        //Split the list into two halves.
        ListNode first = head;
        ListNode second = slow.next;
        slow.next = null; //this marks the end of the 1st half and properly breaks the list into two parts

        //Reverse the second half of the list.
        second = reverseList(second);

        //Merge the two halves one node at a time.
        while(second != null){
            ListNode temp1 = first.next;
            ListNode temp2 = second.next;
            
            first.next = second; // Link first half to second half
            second.next = temp1; // Link second half back to first half

            first = temp1; // Move first to the next node in the first half
            second = temp2; // Move second to the next node in the second half
        }
    }

    private ListNode reverseList(ListNode head){
        ListNode prev = null;
        ListNode curr = head;

        while(curr != null){
            ListNode temp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}
