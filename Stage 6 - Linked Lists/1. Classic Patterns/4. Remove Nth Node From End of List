https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/

https://www.youtube.com/watch?v=3kMKYQ2wNIU

Input : Node
Keywords : nth node from end, middle of LL, cycle, one-pass linked list => fast and slow pointers
Constraints : The number of nodes in the list is sz.
              1 <= sz <= 30
              0 <= Node.val <= 100
              1 <= n <= sz

//Brute Force - iterative 2 - more intuitive
//TC = O(2L) => L for size and approx L for 2nd ttaversal
//SC = O(1)

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int size = 0;
        ListNode temp = head;

        // Count the total number of nodes in the list
        while(temp != null){
            size++;
            temp = temp.next;
        }

        int pos = size - n + 1; // Calculate the position of the node to remove from the start
        
        // If the node to remove is the head, return the next node
        if (pos == 1) {
            return head.next;
        }
        
        temp = head;
        
        // Traverse to the node just before the one to remove
        for(int i = 1; i < pos-1; i++){
            temp = temp.next;
        }

        // Skip the node to be removed by making current node point to the one after the next node
        temp.next = temp.next.next;

        return head;
    }
}


//Optimal - Fast and slow pointer
- We move fast by n steps first.
- Since we already moved fast by n steps, when fast is at last node, slow will be at the index just before the node we need to delete.
- then just make slow's next skip the node to delete

//TC = O(L) since the fast pointer will traverse the entire linked list, where L is the length of the linked list. 
       From 0 to n in the for loop and then from n+1 to end of LL in while loop//Brute Force - iterative 2 - more intuitive
//TC = O(2L)
//SC = O(1)
//SC = O(1), as we have not used any extra space.

class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode slow = head;

        // Move the fast pointer by 'n' first
        for(int i = 0; i < n; i++){
            fast = fast.next;
        }

        if(fast == null){// this means the head has been asked to delete, so we return the next node as the new head. Eg: head = [1,2,3,4,5], n = 5, this means node = 1 has been asked to delete. So node = 2 becomes new head.
            return head.next;
        }

        //Since we already moved fast by n steps, when fast is at last node, slow will be at the
        //index just before the node we need to delete
        while(fast.next != null){ //make sure that fast is at last node and not at null
            fast = fast.next;
            slow = slow.next;
        }

        //At this point, slow will point to the previous node of the one we want to delete
        slow.next = slow.next.next;

        return head;
    }
}
