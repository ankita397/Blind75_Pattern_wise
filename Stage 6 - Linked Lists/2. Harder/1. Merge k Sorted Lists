https://leetcode.com/problems/merge-k-sorted-lists/description/

https://www.youtube.com/watch?v=1zktEppsdig

Input : Array of Linked list
Keywords : sorted lists, merge, "k" => Priority Queue / Min Heap
Constraints :   k == lists.length
                0 <= k <= 104
                0 <= lists[i].length <= 500
                -104 <= lists[i][j] <= 10^4
                lists[i] is sorted in ascending order.
                The sum of lists[i].length will not exceed 10^4.

//Brute Force - exactly same as 21. Merge Two Sorted Lists

//TC = O(KN) + O(M log M) + O(M)  -> for loop, sorting, convert function

    K = lists.length = size of the given list of LLs,
    N = each linked list size, 
    M = N*K (total no of elements in the nodeList

//SC = O(M)+O(M) - arraylist , new Linked list
    M = the total number of nodes from all lists, N1 + N2 + N3...+Nk. O(M) to store all the nodes of both the lists in an 
                    external array and another O(N) to create a new combined list.


class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ArrayList<Integer> arrList = new ArrayList<Integer>();
        for(int i = 0; i < lists.length; i++){
            ListNode temp = lists[i];
            while(temp != null){
                arrList.add(temp.val);
                temp = temp.next;
            }
        }
        Collections.sort(arrList);
        return convertArrayListToLinkedList(arrList);
    }

    private ListNode convertArrayListToLinkedList(ArrayList<Integer> arrList){
        ListNode dummyNode = new ListNode(-1);

        ListNode temp = dummyNode;
        for(int i = 0; i < arrList.size(); i++){
            temp.next = new ListNode(arrList.get(i));
            temp = temp.next;
        }
        return dummyNode.next;
    }
}

//Better - similar to 21. Merge Two Sorted Lists  => sort in-place

INTUITION - merge k sorted linked lists by starting with the first list and merging it one by one with each of the other lists using a helper function

//TC  = ~ O(n^3) 
                N1+N2 + (N1+N2+N3) + (N1+N2+N3+N4) = N(1+2+...+k) = N * ((K * K+1)/2) where k is the number of lists and 
                n is the average number of nodes per list, 
                as each merge operation takes O(n) and we perform it kâˆ’1 times.

                N * ((K * K+1)/2) = ~ N^3 (assuming k ~ N)

//SC = O(1) - We just use the existing linked lists and link them in sorted manner. No extra space is used

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0){
            return null;
        }
        ListNode head = lists[0]; // head will be initialised with first LL
        for(int i = 1; i < lists.length; i++){
            head = mergeTwoSortedList(head, lists[i]); // head will keep storing merged LLs
        }
        return head;
    }   

    private ListNode mergeTwoSortedList(ListNode t1, ListNode t2){
        ListNode dummyNode = new ListNode(-1);

        ListNode temp = dummyNode;

        while(t1 != null && t2 != null){
            if(t1.val < t2.val){
                temp.next = t1;
                t1 = t1.next;
            }else{
                temp.next = t2;
                t2 = t2.next;
            }
            temp = temp.next;
        }

        if(t1 != null){
            temp.next = t1;
        }else{
            temp.next = t2;
        }

        return dummyNode.next;
    }
}

//Optimal - Min Heap (Priotity Queue)

// TC ~ O(N log k), where:
            // N = total number of nodes across all lists
            // k = number of linked lists
            
            // Explanation:
            // - Initial insertion of up to k head nodes into the priority queue: O(k log k)
            // - For each of the N nodes:
            //     - One poll from the priority queue: O(log k)
            //     - One offer (if the node has a next): O(log k)
            //   => Total for all nodes: O(N log k)
            // Final time complexity is O(N log k)

            // Note:
            // - Priority queue size is at most k at any time

//SC = O(k) - pq

//pq operations(offer, poll,etc) take O(log K) where K = size of pq 

offer - can be replaced with pq.add(node)
poll - remove the top and return it

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null || lists.length == 0){
            return null;
        }
        // Create a priority queue that sorts ListNode objects by their values
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        for(int i = 0; i < lists.length; i++){
            if(lists[i] != null){
                pq.offer(lists[i]); // Add each non-null head node directly 
            }
        }

        ListNode dummyNode = new ListNode(-1);
        ListNode temp = dummyNode;
        while(!pq.isEmpty()){
            // Remove the node with the smallest value from the heap
            ListNode minNode = pq.poll();
            temp.next = minNode;
            temp = temp.next;
            // If the extracted node has a next node, add it to the queue
            if(minNode.next != null){
                pq.offer(minNode.next);
            }
        }
        return dummyNode.next;
    }
}
