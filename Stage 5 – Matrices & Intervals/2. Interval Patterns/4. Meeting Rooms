https://www.geeksforgeeks.org/problems/attend-all-meetings/1

Did on own using Non-overlapping intervals logic and used CHATGPT for correction

Input : array
Keywords : interval, overlap =>  Interval Pattern
Constraints : 0 <= arr.length <= 10^5 => O(n), O(nlog n)


Approach - Greedy

//Optimal - Sort meetings by start time and check if any meeting starts before the previous one ends 
// by keeping track of the end of last non-overlapping meetings meeting.

//This is similar to pervious problem (Non-overlapping intervals)

Sort intervals by their start time.
Keep track of the end of the last non-overlapping interval.
For each remaining interval:
  - If current interval starts before end of last non-overlapping interval, return false
  - Otherwise, keep updating end of the last non-overlapping interval.
Return true if false is not already returned.

//TC = O(nlog n)
//SC = O(1)

public boolean canAttend(int[][] arr) {
    // Sort the intervals by their start time (ascending)
    Arrays.sort(arr, (a, b) -> a[0] - b[0]);

    int endOfLast = arr[0][1]; //end of last non-overlapping meeting

    for (int i = 1; i < arr.length; i++) {
        // If the current meeting starts before the previous one ends, there's an overlap
        if (arr[i][0] < endOfLast) {
            return false; // Cannot attend all meetings
        }

        // Update the end time to the current meeting's end time
        endOfLast = arr[i][1];
    }

    // No overlaps found, all meetings can be attended
    return true;
}

//[1, 4], [10, 15], [7, 10]
//[1, 4], [7, 10], [10, 15] - sorted
// 1            4
//                          7           10
//                                      10                  15
// o/p : true

//[2, 4], [9, 12], [6, 10]
//[2, 4], [6, 10], [9, 12] - sorted
//     2        4
//                      6               10
//                                  9           12
// o/p : false
