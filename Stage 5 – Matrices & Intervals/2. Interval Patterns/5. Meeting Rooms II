https://www.geeksforgeeks.org/problems/attend-all-meetings-ii/1

Did on own using Non-overlapping intervals logic and used CHATGPT for correction

Input : array
Keywords : interval, overlap, start, end =>  Interval Pattern
Constraints : 0 <= intervals.length <= 10^5 => O(n), O(nlog n)


- Sort both start and end times.
- Use two pointers (startPointer and endPointer).
- Compare the current meeting's start time with the earliest end time to decide if a room can be reused or if a new room is needed.
- Track the maximum rooms needed throughout the process, which will give the final result.

//Optimal - 2 pointers
//TC = O(nlog n)
//SC = O(n)

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }

        int n = intervals.length;
        int[] starts = new int[n];
        int[] ends = new int[n];

        // Step 1: Fill start and end times into separate arrays
        for (int i = 0; i < n; i++) {
            starts[i] = intervals[i][0];
            ends[i] = intervals[i][1];
        }

        int startPointer = 0;
        int endPointer = 0;
        
        while(startPointer < n){
            //if a new meeting starts before previous one ends => increment
            //we need new room
            if(start[startPointer] < end[endPointer]){
                countRooms++;
            }else{
                //new meeting starts after previous one ends - check next end
                //same meeting room can be used
                endPointer++;
            }
            // Always move the startPointer to the next meeting
            startPointer++;
        }
        return countRooms;
    }
}
