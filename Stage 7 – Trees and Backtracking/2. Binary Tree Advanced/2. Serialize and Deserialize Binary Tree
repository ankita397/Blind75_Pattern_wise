https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/

https://www.youtube.com/watch?v=-YbXySKJsX8

Input : TreeNode, String
Keywords : binary tree => bfs/dfs
Constraints : The number of nodes in the tree is in the range [0, 10^4].
              -1000 <= Node.val <= 1000

Note : Can use BFS or DFS as well.

//Approach - Level Order Traversal / BFS

//TC = O(N)
//SC = O(N)
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null){
            return "";
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);

        StringBuilder res = new StringBuilder();
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node == null){ // If the node is null, append "null" to represent a missing child
                res.append("null,");
                continue;
            }
            res.append(node.val + ",");

            //We always add left and righ nodes irrespective of whether they are null because our
            //serialised string needs "null" placeholders too
            queue.add(node.left);
            queue.add(node.right);
        }
        return res.toString(); // o/p : 1,2,3,null,null,4,5,null,null,null,null,
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data == null || data.isEmpty()){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        String[] dataArray = data.split(","); // split on the basis of ','

        TreeNode root = new TreeNode(Integer.parseInt(dataArray[0]));
        queue.add(root);
        
        int i = 1;
        while(!queue.isEmpty() && i < dataArray.length){ // i should not exceed array length
            TreeNode parentNode = queue.poll(); // current parent

             // Process the left child of the parent node
            if(!dataArray[i].equals("null")){
                //Create the left child node and attach it to parent node, then add to queue for next iteration
                TreeNode leftNode = new TreeNode(Integer.parseInt(dataArray[i]));
                parentNode.left = leftNode;
                queue.add(leftNode);                
            }
            i++; // move to next element in array

             // Process the right child of the parent node
            if(!dataArray[i].equals("null") && i < dataArray.length){
                //Create the right child node and attach it to parent node, then add to queue for next iteration
                TreeNode rightNode = new TreeNode(Integer.parseInt(dataArray[i]));
                parentNode.right = rightNode;
                queue.add(rightNode);       
            }
            i++; // move to next element in array
        }
        return root;
    }


//Approach - DFS (preorder) traversal.
//TC = O(N)
//SC = O(N)
public class Codec {

    public String serialize(TreeNode root) {
        StringBuilder output = new StringBuilder();
        
        dfsSerialize(root, output);
        
        return output.toString();
    }

    // Helper function for DFS (preorder) traversal serialization
    private void dfsSerialize(TreeNode node, StringBuilder sb){
        if(node == null){
            sb.append("null ");
        } else {
            sb.append(node.val + " ");
            dfsSerialize(node.left, sb);  // Left child
            dfsSerialize(node.right, sb); // Right child
        }
    }

    public TreeNode deserialize(String data) {
        List<String> nodes = new ArrayList<>(Arrays.asList(data.split(" ")));
        
        return dfsDeserialize(nodes);
    }

    private TreeNode dfsDeserialize(List<String> nodes){
        if (nodes.isEmpty()){
            return null;
        }
        
        // Get and remove the first value from the list, which corresponds to the current node
        String currNodeVal = nodes.remove(0);
        
        if (currNodeVal.equals("null")){
            return null;
        }
        
        TreeNode node = new TreeNode(Integer.parseInt(currNodeVal));
        
        // Recursively build the left and right children of the current node
        node.left = dfsDeserialize(nodes);
        node.right = dfsDeserialize(nodes);

        // Return the current node (with its left and right subtrees already set)
        return node;
    }
}
}
