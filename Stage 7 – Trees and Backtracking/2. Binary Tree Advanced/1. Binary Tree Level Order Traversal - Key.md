https://leetcode.com/problems/binary-tree-level-order-traversal/description/

https://www.youtube.com/watch?v=EoAsWbO7sqg

Input : TreeNode root
Keywords : binary tree, level order => bfs best
Constraints : The number of nodes in the tree is in the range [0, 2000].
              -1000 <= Node.val <= 1000

//Approach - BFS -- BEST (can also be solved usin DFS)

//TC = O(N) - Each node in the tree is processed once, where N is the total number of nodes.
//SC = O(N) + O(N) ~ O(N) - The queue can hold up to N nodes in the worst case (if all nodes are in a single level) + The result list 
//also requires O(N) space.

``` java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> levelOrderList = new ArrayList<>(); //final output list with nodes in level order
        // need to handle this as we check root's left and right later and if not handled it will throw NPE
        if(root == null){
            return levelOrderList;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();// Queue to keep track of nodes at each level
        queue.add(root);

        while(!queue.isEmpty()){
            int levelSize = queue.size(); // size of queue in a level - needed to iterate queue

            List<Integer> levelWiseList = new ArrayList<>();
            for(int i = 0; i < levelSize; i++){
                TreeNode node = queue.poll();

                //if left child exists, then add to queue
                if(node.left != null){
                    queue.add(node.left);
                }

                //if left child exists, then add to queue
                if(node.right != null){
                    queue.add(node.right);
                }

                levelWiseList.add(node.val);
            }
            levelOrderList.add(levelWiseList);
        }
        return levelOrderList;
    }
}
