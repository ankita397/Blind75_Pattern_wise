üîÅ Recursion / DP Direction Cheat Sheet (Expanded)
| Problem Type               | Direction            | Typical State               | Key Recurrence Idea     | Common Examples                             | Intuition Hook                 |
| -------------------------- | -------------------- | --------------------------- | ----------------------- | ------------------------------------------- | ------------------------------ |
| **Pick / Not Pick**        | ‚û°Ô∏è Forward           | `f(i, prev)` or `f(i, sum)` | Take current or skip    | LIS, Subsets, Combination Sum, 0/1 Knapsack | *‚ÄúDecide now, move on‚Äù*        |
| **Sequence Alignment**     | ‚¨ÖÔ∏è Backward (prefix) | `f(i, j)`                   | Match ‚Üí diag, else skip | LCS, Edit Distance, SCS                     | *‚ÄúCompare shorter prefixes‚Äù*   |
| **Suffix Alignment (alt)** | ‚û°Ô∏è Forward           | `f(i, j)`                   | Match ‚Üí forward diag    | LCS (suffix version)                        | *‚ÄúCompare remaining suffixes‚Äù* |
| **Paths / Movement**       | ‚û°Ô∏è Forward           | `f(pos)` or `f(r, c)`       | Move to next step/cell  | Climbing Stairs, Unique Paths, Frog Jump    | *‚ÄúSimulate motion‚Äù*            |
| **Reduction / Math**       | ‚¨ÖÔ∏è Toward smaller    | `f(n)`                      | Reduce problem size     | Binary Search, Power(x,n), GCD              | *‚ÄúShrink until trivial‚Äù*       |
| **Tree / Graph DP**        | ‚¨ÜÔ∏è Bottom-up         | `f(node)`                   | Combine children        | Tree Height, Diameter, Max Path Sum         | *‚ÄúChildren first‚Äù*             |
| **Interval / Range DP**    | ‚ÜîÔ∏è Inward            | `f(l, r)`                   | Split or shrink         | Matrix Chain, Burst Balloons                | *‚ÄúSolve inside first‚Äù*         |
| **Counting DP**            | ‚û°Ô∏è Forward           | `f(i, count)`               | Accumulate ways         | Coin Change, Target Sum                     | *‚ÄúAccumulate outcomes‚Äù*        |
| **State Compression**      | ‚û°Ô∏è Forward           | `f(i, mask)`                | Add/remove bits         | Traveling Salesman, Bitmask DP              | *‚ÄúBuild states‚Äù*               |



Typical State = what one recursive call represents in plain English
‚ÄúIf I pause the recursion right here, what subproblem am I solving?‚Äù

üß† Typical DP / Recursion States ‚Äî Clear Language
| Problem Type     | Typical State | What it means (plain English)                                                                            | Example                     |
| ---------------- | ------------- | -------------------------------------------------------------------------------------------------------- | --------------------------- |
| Pick / Not Pick  | `f(i, prev)`  | Best answer **using elements starting at index `i`**, given last chosen element is at `prev`             | LIS                         |
| Pick / Not Pick  | `f(i, sum)`   | Number of ways **to reach `sum` using elements starting at index `i`**                                   | Subset Sum                  |
| Sequence Match   | `f(i, j)`     | Best match of **first `i` characters of string 1** and **first `j` characters of string 2`**             | LCS                         |
| Sequence Match   | `f(i, j)`     | Minimum operations **to convert first `i` characters of string 1 into first `j` characters of string 2** | Edit Distance               |
| Paths / Movement | `f(pos)`      | Number of ways or cost **to reach the destination starting from position `pos`**                         | Climbing Stairs             |
| Grid Paths       | `f(r, c)`     | Number of ways or cost **to reach the destination starting from cell `(r, c)`**                          | Unique Paths                |
| Tree DP          | `f(node)`     | Answer for **the subtree rooted at this node**                                                           | Tree Height                 |
| Interval DP      | `f(l, r)`     | Answer for **the subarray or substring from index `l` to `r` inclusive**                                 | Matrix Chain Multiplication |
| Knapsack         | `f(i, cap)`   | Maximum value **using items starting at index `i` with remaining capacity `cap`**                        | 0/1 Knapsack                |
| Counting / Sum   | `f(i, cnt)`   | Number of ways **to reach `cnt` using elements starting at index `i`**                                   | Coin Change                 |
