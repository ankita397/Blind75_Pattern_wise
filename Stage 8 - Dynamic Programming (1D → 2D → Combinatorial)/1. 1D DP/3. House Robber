https://leetcode.com/problems/house-robber/description/

https://www.youtube.com/watch?v=GrMBfJNk_NY

Approach - DP - Recursion -> Memoization -> Tabulation -> Space optimization

//1. Express everything in terms of index
//2. Try all possible ways
//3. Find max amount robbed
//4. Base case


Input : int
Keywords : maximum amount(optimize), adjacent houses have security systems(constraint)  => recursion/dp 
Constraints : 1 <= nums.length <= 100 => O(nÂ²), O(n log n), O(n)
              0 <= nums[i] <= 400


//Recursion  
//TC = O(2^n) - TLE
//SC = O(n) - recursion stack space
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        return maxAmountRobbed(n-1, nums);
    }
    private int maxAmountRobbed(int index, int[] nums){
        //base case
        if(index == 0){// we pick 0 only if 1 has not been picked
            return nums[index]; // since index = 0 got picked
        }
        if(index < 0){
            return 0;
        }
        int pick = nums[index] + maxAmountRobbed(index-2, nums);
        int notPick = maxAmountRobbed(index-1, nums);

        return Math.max(pick, notPick);
    }
}

//Memoization 
TC = O(n) 
SC = O(n)+ O(n) - recursion stack space + dp array
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n+1];
        for(int i = 0; i < n+1; i++){
            dp[i] = -1;
        }
        return maxAmountRobbed(n-1, nums, dp);
    }
    private int maxAmountRobbed(int index, int[] nums, int[] dp){
        //base case
        if(index == 0){
            return nums[index];
        }
        if(index < 0){
            return 0;
        }

        if(dp[index] != -1){
            return dp[index];
        }

        int pick = nums[index] + maxAmountRobbed(index-2, nums, dp);
        int notPick = maxAmountRobbed(index-1, nums, dp);

        return dp[index] = Math.max(pick, notPick);
    }
}

//Tabulation 
//TC = O(n) 
//SC = O(n) - dp array
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n+1];
   
        dp[0] = nums[0];// same as if(ind == 0){return nums[ind];}

        // if ind < 0, we cannot handle it here.. we do it later

        int pick = 0;
        int notPick = 0;

        for(int index = 1; index < n; index++){ // loop till n-1 and not n because here we loop nums array(not dp array)
            pick = nums[index];
            if(index > 1){// handle boundary
                pick = nums[index] + dp[index-2];
            }
            notPick = dp[index-1];
            dp[index] = Math.max(pick, notPick);
        }

        return dp[n-1];
    }
}

//Space Optimization  
TC = O(n)
SC = O(1)
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
   
        int prev = nums[0];// same as if(ind == 0){return nums[ind];} // dp[index-1]
        int prev2 = 0; // dp[]index-2
        // if ind < 0, we cannot handle it here.. we do it later

        int pick = 0;
        int notPick = 0;

        for(int index = 1; index < n; index++){
            int curr = 0;
            pick = nums[index];
            if(index > 1){
                pick = nums[index] + prev2;
            }
            notPick = prev;
            curr = Math.max(pick, notPick);
            prev2 = prev;
            prev = curr;
        }

        return prev;
    }
}
