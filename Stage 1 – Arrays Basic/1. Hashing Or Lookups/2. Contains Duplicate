https://leetcode.com/problems/contains-duplicate/description/

https://www.youtube.com/watch?v=3OamzN90kPg
https://www.youtube.com/watch?v=4oZsPXG9B94

//Eg : Input: nums = [1,2,3,1]
//Output: true

Pattern Keyword : Duplicate => HashSet

Constraint : 1 <= nums.length <= 10^5 => O(n) should be ok

//Brute force
//TC = O(n^2) - TLE
//SC = O(1)
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                if(nums[i] == nums[j]){
                    return true;
                }
            }
        }
        return false;
    }
}

//Note : hashset to get unique values in array, to check for duplicates easily. first check and then add to set

//Better - Adds all elements to hashset first and then checks for size. Does not exit early if duplicate found â€” always processes whole array.
//TC : O(n)
//SC = O(n)
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int n = nums.length;
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < n; i++){
            set.add(nums[i]);
        }
        if(set.size() != n){
            return true;
        }
        return false;
    }
}


//Optimal - More efficient as it does returns if duplicate is found and does not process the entire array then.
//TC : O(n)
//SC = O(n)

class Solution {
    public boolean containsDuplicate(int[] nums) {
        int init_count = nums.length;
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < init_count; i++){
            if(set.contains(nums[i])){
                return true;
            }
            set.add(nums[i]);
        }
        return false;
    }
}
