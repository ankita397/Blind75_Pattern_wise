https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

https://www.youtube.com/watch?v=-zSxTJkcdAo

Input : String
Keywords : substring => Sliding Window
Constraints : 0 <= s.length <= 5 * 10^4 => O(n log n), O(n)

//Brute force
//TC = O(n^2) // O(n*n*1) - O(1) for for accessing set
//O(n) // set will have size n if all characters are unique in the string
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLen = 0;

        if(n == 0)
            return 0;

        //try every possible starting index 'i'
        for(int i = 0; i < n; i++){
            Set<Character> set = new HashSet<Character>();
            //extend the substring from index 'i' to 'j'
            for(int j = i; j < n; j++){
                char c = s.charAt(j);
                // If the character is already in the set, we found a repeat
                if(set.contains(c)){
                    break;
                }
                // Add the unique characters only to the set
                set.add(c);
                //update maxLen
                maxLen = Math.max(maxLen, j - i + 1);
            }
        }
        return maxLen;
    }
}

//Better but slow (Interviewers do not prefer this)
//Uses Set - More intuitive
//TC = O(n)
//SC = O(n) // set will have size n if all characters are unique in the string
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLen = 0;
        int left = 0;
        int right = 0;
        Set<Character> set = new HashSet<>();

        if(n == 0)
            return 0;

        //Expand the window by moving 'right' pointer
        while(right < n){
            char c = s.charAt(right);

            // If character 'c' not in set, add it and update maxLen
            if(!set.contains(c)){
                set.add(c);
                maxLen = Math.max(maxLen, right -  left + 1);
                right++;
            }else{
                // If 'c' is duplicate, shrink window from the left
                // Remove character at 'left' and move left pointer forward
                set.remove(s.charAt(left));
                left++;
            }
        }
        return maxLen;
    }
}

//Optimal - Sliding window with 2 pointers (best)
//using array for storing each character's index

//TC = O(n)
//SC = O(1)
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLen = 0;
        int left = 0;
        int right = 0;
        
        // Store last seen position of each char
        int[] lastSeenIndex = new int[256];
        for(int i = 0; i < 256; i++){
            lastSeenIndex[i] = -1;
        }

        while(right < n){
            char currentChar = s.charAt(right);

            //********** See dry run below
            // If currentChar was seen before and is inside current window,
            // move left (new window start) just past its last seen position to avoid duplicates
            if((lastSeenIndex[currentChar] != -1) && (lastSeenIndex[currentChar] >= left)){
                left = lastSeenIndex[currentChar] + 1;
            }

            // Update last seen index for currentChar as the "right" index is its new last seen position
            lastSeenIndex[currentChar] = right;

            //Update maxLen 
            maxLen = Math.max(maxLen, right - left + 1);
            // expand window from the right include the next character in the string.
            right++;       
        }

        return maxLen;
    }
}


//**********
// Eg: in cadbzabcd, for substring "cadbza" where right = 'a'(index 5), we found 'a' repeating
// so, we need to move left beyond charIndex[s.charAt(right)] 
// left = charIndex[s.charAt(right)]+1 -- i.e; left = 1+1=2
// this lets us skip left at index 1 where we have a first.
left = charIndex[s.charAt(right)]+1;
