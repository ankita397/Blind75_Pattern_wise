//https://leetcode.com/problems/product-of-array-except-self/description/

//https://www.youtube.com/watch?v=G9zKmhybKBM

Input : Array
Keywords : Product "except" self - Prefix/suffix 
Constraints: 2 <= nums.length <= 10^5 => O(n) , O(nlogn)


//Brute force - Go over all elements and multiplying unless i == j
//TC = O(n^2)
//SC = O(n)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int answer[] = new int[n];

        for(int i = 0; i < n; i++){
            int product = 1;
            for(int j = 0; j < n; j++){
                if(i != j){
                    product = product * nums[j];
                }
            }
            answer[i] = product;
        }
        return answer;
    }
}

//Optimal - Use prefix/suffix products to calculate the final answer
//TC = O(n)
//SC = O(n)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int answer[] = new int[n];

        // Step 1: Compute prefix product for each index 
        int[] leftProduct = new int[n];
        leftProduct[0] = 1;
        for(int i = 1; i < n; i++){
            leftProduct[i] = leftProduct[i-1] * nums[i-1];
        }

        // Step 2: Compute suffix product for each index 
        int[] rightProduct = new int[n];
        rightProduct[n-1] = 1;
        for(int i = n-2; i >= 0; i--){
            rightProduct[i] = rightProduct[i+1] * nums[i+1];
        }

        // Final result = prefix[i] * suffix[i]
        for(int i = 0; i < n; i++) {
            answer[i] = leftProduct[i] * rightProduct[i];
        }
        return answer;
    }
}

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)

//Little Different - Keep left products in output array and right products in variable
//Left Products: You need the cumulative product for all previous indices, so you need to store intermediate results in the output array.
//Right Products: You can maintain a running product in a single variable because you’re moving backwards through the array, allowing you to update it directly.

//TC = O(n) 
//SC = O(1)
class Solution { 
    public int[] productExceptSelf(int[] nums) {
        int[] output = new int[nums.length];
        output[0] = 1;
        for(int i = 1; i < nums.length; i++){// use output array for all left products
           output[i] = nums[i-1] * output[i-1];
           //System.out.println("Left :"+ output[i]);
        }
        
        int right_products  = 1;
        for(int i = nums.length-1; i >= 0; i--){// use variable for all right products
          output[i] = output[i] * right_products;
          right_products = right_products * nums[i]; // when calculating the right products, 
//we can use a single variable (right_products) because we’re processing the array in reverse.
          //System.out.println("Right :"+ output[i]);
        }

        return output;
    }
}
